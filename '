#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "klog/klog.h"

#include "../klog_state.h"
#include "../klog_format.h"

int no_async_param(void) {
    const uint32_t logger_name_length = 6;
    KlogFormatInfo format_info = {logger_name_length, 10, 0, false, false};
    KlogConsoleInfo console_info = {KLOG_LEVEL_INFO, false};
    klog_initialize(5, format_info, NULL, &console_info, NULL);

    if (g_klog_state.prefix_element_index != 0) {
        printf("Klog prefix element index should be 0 before anything is logged\n");
        return 1;
    }

    if (g_klog_state.prefix_element_count != 1) {
        printf("Klog prefix element count should be 1 if no async parameter is provided\n");
        return 1;
    }

    const uint32_t prefix_size = klog_format_prefix_length_get(false, false, logger_name_length, false, 0);
    if (g_klog_state.prefix_file_size != prefix_size) {
        printf("Klog file prefix size should be %d, but actually is %d\n", prefix_size, g_klog_state.prefix_console_size);
        return 1;
    }
    if (g_klog_state.prefix_console_size != prefix_size) {
        printf("Klog console prefix size should be %d, but actually is %d\n", prefix_size, g_klog_state.prefix_console_size);
        return 1;
    }

    char* empty_buffer = malloc(prefix_size);
    memset(empty_buffer, 0, prefix_size);
    if (g_klog_state.b_prefixes_file == NULL) {
        printf("Klog file prefix buffer is not initialized\n");
        return 1;
    }
    if (g_klog_state.b_prefixes_console == NULL) {
        printf("Klog console prefix buffer is not initialized\n");
        return 1;
    }
    if (memcmp(g_klog_state.b_prefixes_file, empty_buffer, prefix_size)) {
        printf("Klog file prefix buffer should be all null characters but it is not\n");
        return 1;
    }
    if (memcmp(g_klog_state.b_prefixes_console, empty_buffer, prefix_size)) {
        printf("Klog console prefix buffer should be all null characters but it is not\n");
        return 1;
    }

    const KlogLoggerHandle* p = klog_logger_create("dummy!");
    klog_logger_set_level(p, KLOG_LEVEL_INFO);
    klog_info(p, "test");

    if (g_klog_state.prefix_element_index != 0) {
        printf("Klog prefix element index should still be 0 because the buffer only has 1 element\n");
        return 1;
    }

    char* full_buffer = "[dummy!] [info ] ";
    if (memcmp(g_klog_state.b_prefixes_file, full_buffer, prefix_size)) {
        printf("Klog file prefix buffer should contain \"%s\" after logging at info level, but instead it contains \"%s\"\n", full_buffer, g_klog_state.b_prefixes_file);
        return 1;
    }
    if (memcmp(g_klog_state.b_prefixes_console, full_buffer, prefix_size)) {
        printf("Klog console prefix buffer should contain \"%s\" after logging at info level, but instead it contains \"%s\"\n", full_buffer, g_klog_state.b_prefixes_console);
        return 1;
    }
    
    free(empty_buffer);

    klog_deinitialize();

    return 0;
}

int single_element(void) {
    const uint32_t logger_name_length = 6;
    KlogFormatInfo format_info = {logger_name_length, 10, 0, false, false};
    KlogAsyncInfo async_info = {1, 3};
    KlogConsoleInfo console_info = {KLOG_LEVEL_INFO, false};
    klog_initialize(5, format_info, NULL, &console_info, NULL);

    if (g_klog_state.prefix_element_index != 0) {
        printf("Klog prefix element index should be 0 before anything is logged\n");
        return 1;
    }

    if (g_klog_state.prefix_element_count != 1) {
        printf("Klog prefix element count should be 1 if no async parameter is provided\n");
        return 1;
    }

    const uint32_t prefix_size = klog_format_prefix_length_get(false, false, logger_name_length, false, 0);
    if (g_klog_state.prefix_file_size != prefix_size) {
        printf("Klog file prefix size should be %d, but actually is %d\n", prefix_size, g_klog_state.prefix_console_size);
        return 1;
    }
    if (g_klog_state.prefix_console_size != prefix_size) {
        printf("Klog console prefix size should be %d, but actually is %d\n", prefix_size, g_klog_state.prefix_console_size);
        return 1;
    }

    char* empty_buffer = malloc(prefix_size);
    memset(empty_buffer, 0, prefix_size);
    if (g_klog_state.b_prefixes_file == NULL) {
        printf("Klog file prefix buffer is not initialized\n");
        return 1;
    }
    if (g_klog_state.b_prefixes_console == NULL) {
        printf("Klog console prefix buffer is not initialized\n");
        return 1;
    }
    if (memcmp(g_klog_state.b_prefixes_file, empty_buffer, prefix_size)) {
        printf("Klog file prefix buffer should be all null characters but it is not\n");
        return 1;
    }
    if (memcmp(g_klog_state.b_prefixes_console, empty_buffer, prefix_size)) {
        printf("Klog console prefix buffer should be all null characters but it is not\n");
        return 1;
    }

    const KlogLoggerHandle* p = klog_logger_create("dummy!");
    klog_logger_set_level(p, KLOG_LEVEL_INFO);
    klog_info(p, "test");

    if (g_klog_state.prefix_element_index != 0) {
        printf("Klog prefix element index should still be 0 because the buffer only has 1 element\n");
        return 1;
    }

    char* full_buffer = "[dummy!] [info ] ";
    if (memcmp(g_klog_state.b_prefixes_file, full_buffer, prefix_size)) {
        printf("Klog file prefix buffer should contain \"%s\" after logging at info level, but instead it contains \"%s\"\n", full_buffer, g_klog_state.b_prefixes_file);
        return 1;
    }
    if (memcmp(g_klog_state.b_prefixes_console, full_buffer, prefix_size)) {
        printf("Klog console prefix buffer should contain \"%s\" after logging at info level, but instead it contains \"%s\"\n", full_buffer, g_klog_state.b_prefixes_console);
        return 1;
    }
    
    free(empty_buffer);

    klog_deinitialize();

    return 0;
}

int multiple_elements(void) {
    return 0;
}

int noop(void) {
    return 0;
}

int main(void) {
    int result =
        no_async_param() ||
        noop()
    ;

    return result;
}
